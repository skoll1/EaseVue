<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<h1>vuex</h1>
	<p>data中需要共享的数据</p>
	<ul>
		<li>
			Vue的状态管理模式，几种存储管理所有应用组件的状态，并以响应的规则保证状态以一种可预测的方式发生改变。
		</li>
		<li>
			应用场景
		</li>
		<li>
			多个组件共享状态时，单向的数据流很容易被破坏，比如很多视图依赖同一状态，来自不同视图的行为需要变更同一状态
		</li>
		<li>
			路由间复杂的参数传递
		</li>
		<li>
			每一个Vuex的核心就是store仓库。里面包含着你应用中的大部分的状态
		</li>
		<li>
			Vuex的状态是响应式的，当从Vue组件中读取状态时，若store的状态发生变化，那么相应的组件也会得到高效的更新
		</li>
		<li>
			改变store中的状态的唯一途径就是提交mutation.
		</li>
	</ul>
	<h1>核心概念</h1>
	<ul>
		<li>
			state:单一的状态树，vuex仅适用一个对象就包含了全部的应用层状态，保证唯一的数据来源，单一的状态树能让我们直接定位任以特定的状态片段。
		</li>
		<li>
			获取：computed（）计算属性，每当store.state.count变化的时候都会重新取值，并且触发更新相关的dom
			<ul>
				<li>
					函数返回数值
				</li>
				<li>
					mapState函数：当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余，使用mapState辅助函数可以帮助我们生成计算属性。
				</li>
			</ul>
		</li>
		<li>
			getter:store的计算属性
			<ul>
				<li>
					mapGetters辅助函数
				</li>
			</ul>
		</li>
		<li>
			Mutation:
			<ul>
				<li>
					最好在store中初始化好所有的需要属性
				</li>
				<li>
					触发store.commit('set_singer')
				</li>
				<li>
					mapMutations
				</li>
				<li>
					mutation必须是同步函数，对于检查工具来说，每一条mutation被记录，都需要捕捉到前一状态和后一状态的快照，但是对于异步函数来说，异步回调让捕捉到下一步的操作成为不可能实现。
				</li>
			</ul>
		</li>
		<li>
			action:异步操作
			<ul>
				<li>
					action提交的是mutation,而不是直接变更的状态
				</li>
				<li>
					提交的是操作
				</li>
				<li>action可以包含任意的异步操作</li>
			</ul>
		</li>
	</ul>
</body>
</html>